---
title: "新しくプログラミング言語を作る際に文字列型をどうするべきか"
emoji: "🌊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["文字列"]
published: false
---

この記事は、新しくプログラミング言語を設計する際に文字列型をどうするべきかについて、私の持論をまとめたものです。

# 文字列とは何か

文字列とは何でしょうか？文字の列ですね。では計算機上での「文字」とは何でしょうか？

計算機に関するやり取りの中での「文字」は警戒すべき単語で、時と場合により以下のいずれかを指す場合があります：

* 7ビットまたは8ビットの整数で表される、符号化された文字（主にアルファベット）
* 16ビット整数で表される、UnicodeのBMPのコードポイント（サロゲートコードポイントを含む）
* UnicodeコードポイントまたはUnicodeスカラー値
    * Unicodeコードポイントは0以上0x10FFFF以下の整数値です。`U+` の後に十六進表記を続けて表記されます。
    * Unicodeスカラー値は、Unicodeコードポイントであって、0xD800以上0xDFFF以下の区間に属さないものです。
* Unicodeの書記素クラスター (grapheme cluster)
    * 詳しい説明は省略しますが、プログラマーでない一般人が「文字」と考えるやつに近そうです。
* その他、なんらかの文字集合の文字をなんらかの符号化方式で表現した整数列

よって、この記事では以後「文字」という用語はなるべく避けることにします。

Unicodeという名前が出てきましたが、Unicodeは現代のプログラミング言語が意識すべき唯一にして最重要の文字集合です。**現代のプログラミング言語はUnicodeをうまく扱える必要があります。** 100年後のIT業界がどうなっているかは分かりませんが、ここ10〜20年以内に普及させたいプログラミング言語はなんらかのUnicodeサポートを盛り込むべきです。

「文字」という用語を避けるとして、文字列とは何なのかという問題に戻ります。バイト列としての表現は脇に置いて、抽象的に見たときに文字列が何を表すかは以下のいずれかに分類できそうです：

1. 8ビット整数列
2. 8ビット整数列とエンコーディングの組
3. 16ビット整数列、ただしエンコーディングはUTF-16を意図する
4. Unicodeコードポイントの列
5. Unicodeスカラー値の列

1はプログラミング言語を作る側にとっては簡単で、単に8ビット整数列を文字列と呼ぶやり方です。C言語の `char` 配列やPHP, Luaなどの文字列が該当します。以下、この方式の文字列を「8ビット文字列」と呼びます。

言語によっては、8ビット文字列をUTF-8とみなして操作する関数を標準で提供していることがあります。GoやLuaが該当します。

2は8ビット文字列にエンコーディングの情報を持たせたものです。Rubyが採用しています。

3は文字列に任意の16ビット整数を格納できるようにしているものです。言うまでもなく、Unicodeが16ビットだった頃にUnicodeを採用した言語、あるいはその頃にUnicodeを採用したシステムの影響を強く受けた言語がこのパターンで、JavaやJavaScript, C\#が該当します。これらの言語やランタイムをターゲットとする（トランスパイルする）言語もこれを踏襲していることが多いです。

4は文字列がUnicodeコードポイントの列であることが保証されているタイプです。3との違いは、 `"\uD800\uDC00"` と `"\U00010000"` を区別できることで、5との違いはサロゲートコードポイントを持てることです。Pythonの `str` が該当します。Pythonは[PEP 383](https://peps.python.org/pep-0383/)でサロゲートコードポイントを有効活用しています。Haskellの `String` も該当します。

5は文字列がUnicodeスカラー値の列であることが保証されているタイプです。Rustの `str` や、Haskellの `Text` が該当します。Swiftの `String` もUnicodeスカラー値の列です。

1から5の分類とは別に、「文字列の中身にヌル文字 `\0` を含められるか」という観点もあります。C言語の文字列はヌル文字を終端として扱うので、中身としてヌル文字を持てません。従って、`char *` は正確には「8ビット整数（ただし0を除く）の列」となります。C言語よりも新しい言語は文字列の途中にヌル文字を持てることが多いですが、OSのAPIはC文字列を期待していることが多いので注意が必要です。**OSのAPIに文字列を渡すときは、中身にヌル文字を含まないことをチェックすべきでしょう。**

# 表現

文字列がメモリー上でどう表現されているかも重要であることが多いです。表すものがUnicode文字列であれば、UTF-8, UTF-16, UTF-32のいずれかで表現することになります。

最近の言語はUTF-8を採用するものが多いです。一方で、「JavaScriptにトランスパイルする」「JVMや.NETで動かす」ことを念頭に置くのであればUTF-16も選択肢に入るでしょう。UTF-32は馬鹿正直に実装するとたとえASCIIのみからなる文字列であっても1文字につき4バイト消費することになり、不利です。

## 不変条件で保証するか否か

表現をUTF-8やUTF-16とする場合、型の不変条件としてUnicodeスカラー値の列としての正しさを保証するかどうかという論点があります。先ほどのセクションで5に挙げたものは保証しています。1と3は保証していません。

型の不変条件として保証する場合、Unicodeの別のエンコーディングへの変換（UTF-8からUTF-16など）の際にエラー処理を考慮しなくて済むという利点があります。ただし、外部から与えられた文字列を受け取る際に検査が必要になります。

保証しない場合は、エンコーディングの変換の際にエラー処理を用意するか、適当な文字（典型的にはU+FFFD）で置き換えるなどの処理をする必要があります。

## 不変条件で保証する場合→エンコーディングを露出するか否か

内部表現を仮にUTF-8としたとして、それを内部実装にとどめるか、型の仕様に明記するかという論点があります。

内部実装にとどめる場合は、文字列の内部表現を変えてもAPI互換性を保てるという利点があります。Haskellの `Text` はバージョン2.0で内部表現をそれまでのUTF-16からUTF-8に変えましたが、大きなAPIの非互換はないはずです[^haskell-text-2.0]。

[^haskell-text-2.0]: もちろん、「高速にUTF-16表現を得られる」という性質が失われるので、ICUの関数を呼ぶ際のコストが増えます。

このほか、複数のターゲットにコンパイルする言語の場合は、ネイティブコンパイルの際にはUTF-8を使い、JVMやJavaScriptにコンパイルする際はUTF-16を使うという戦略があり得るかもしれません。

型の仕様に明記する場合は、整数のインデックスを使った操作（検索、部分文字列等）を外部に露出できるというメリットがあります。

<!-- インデックス操作の計算量がどうなるかという点と関係してきます。 -->

## UTF-16またはUTF-32を採用する場合の工夫

文字列型の用途は様々ですが、中身としてASCIIの範囲の文字は無視できない割合で存在することが見込まれます。すると、真面目に1コードポイントにつき2バイト（UTF-16の場合）、あるいは4バイト（UTF-32の場合）割り当てるのは馬鹿らしいです。

よって、「文字列の中身がすべて8ビットの範囲（ASCIIもしくはLatin-1）に収まる場合はバイト列として表現する」という戦略が考えられます。

UTF-32の場合は、「文字列の中身がすべて16ビット（BMP）に収まる場合は16ビット列として表現する」という戦略があり得ます。

* Python: [PEP 393 – Flexible String Representation | peps.python.org](https://peps.python.org/pep-0393/)
* Java: [JEP 254: Compact Strings](https://openjdk.org/jeps/254)
    * Latin-1 or UTF-16
* Guile: [String Internals (Guile Reference Manual)](https://www.gnu.org/software/guile/manual/html_node/String-Internals.html)
    * Latin-1 or UTF-32

これらの戦略を採用する前提条件としては、「文字列がimmutableである」ことが必要です。mutableな文字列の場合は書き換えで「文字列の中身が8ビットまたは16ビットに収まる」という条件が崩れる可能性があり、「1文字書き換えようとしただけなのに文字列全体のコピーが走った」という事態になります。

欲しくなる条件：16ビット列もしくは32ビット列でのランダムアクセス

用途によってはASCIIが圧倒的に多い。UTF-16やUTF-32とする場合でも、中身がASCIIやLatin-1に収まる場合は8ビット列として保持するという手がある（例：Python, Java, Guile）。UTF-32の場合で中身がBMPに収まる場合も同様。

# 性質

## immutableにするかどうか

文字列型はimmutableにすべき。
言語によってはinternしている。

書き換え：ほとんどの「書き換え」は実際追記なのでは。追記はStringBuilderで。

## ランダムアクセスが必要かどうか

コードポイント（あるいはスカラー値）列へのランダムアクセスは必要か？イテレーターで十分ではないか？

抽象的な列としてのviewのみを提供するという手もある。HaskellのTextとか。

# 悪い例

## ワイド文字列 (C/C++)

今となっては……。

* プラットフォームによって内容が異なる
* ASCII主体の時にメモリー効率が悪い

## C++の `basic_string`

`std::u8string` は

* 中身が正当なUTF-8であることが保証されていない
* UTF-16やUTF-32に一発で変換するためのメンバー関数が生えていない
* コードポイントの列としてみなすためのiteratorがない

の三重苦です。

## Haskellの `String`

Haskell標準の文字列型は、「文字 `Char` のリスト」として定義されています。`Char` は具体的にはUnicodeコードポイントです。

```haskell
type String = [Char]
```

シンプルな定義に見えますが、Haskellのリストは連結リストであり、実は非常に空間効率が悪いです。具体的には64ビット環境では1文字あたり40バイト（5ワード）消費します。

実用的なHaskellコードでは、`Text` （Unicodeスカラー値の列）や `ByteString` （バイト列）が使われます。

## Haxeの `String`

* [String - Haxe - The Cross-platform Toolkit](https://haxe.org/manual/std-String.html)
    * [Encoding - Haxe - The Cross-platform Toolkit](https://haxe.org/manual/std-String-encoding.html)
* [String - Haxe 4.2.5 API](https://api.haxe.org/String.html)

## `wxString`

# 関数型インターフェース

```haskell
uncons :: Text -> Maybe (Char, Text)
```

```sml
val getc : substring -> (char * substring) option
```

スライスである必要がある。

# OSの文字列

ファイル名とかコマンドライン引数とか環境変数とか。

Windows: UTF-16（を意図する16ビット整数列）

Unix: ロケール依存。iconvとかを使う？

ファイルの中身はロケールとかに依存せずにUTF-8として扱う or 毎度明示的に指定させる方が良いかも。Python UTF-8 Mode, Haskellのやつ。

OSのAPIはNUL終端文字列とすることが多い。NULを途中に含む文字列をOSに渡せるようにしてしまうと、アプリケーションとOSで見える文字列が違ってしまうので脆弱性の原因になりうる。

# ケーススタディー

Rubyの文字列

Rust

Go

Lua

JavaScript

C#: 最近runeができたらしい。

Swift

* [Strings and Characters | Documentation](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters/)
* [Swift.org - UTF-8 String](https://www.swift.org/blog/utf8-string/)
