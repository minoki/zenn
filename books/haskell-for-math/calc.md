---
title: "対話環境で遊ぶ"
---

# Haskellでの四則演算と、数の扱い

コンピューターができるのは計算です。まずは、簡単な計算をさせてみましょう。

端末（ターミナルやコマンドプロンプト）を開いて、

```sh
$ ghci
```

と打ち込みます。すると、次のような文言が表示され、入力待ち状態になります。

```
GHCi, version 9.6.2: https://www.haskell.org/ghc/  :? for help
ghci> 
```

この状態でHaskellの式を入力すると、結果が表示されます。これを**対話環境** (interactive environment)と呼びます。REPL (read-eval-print loop)とも呼ばれることがあります。

対話環境には、Haskellの式以外に、対話環境自体への命令であるコマンドを入力することもできます。そういうコマンドはコロン `:` から始まります。

対話環境を終了する（「抜ける」）には、 `:quit` コマンドを実行します。`:quit` の5文字を打ち込んでみましょう（`ghci>` の部分は入力しません）：

```
ghci> :quit
```

すると `Leaving GHCi.` というメッセージが表示されて、元の端末に戻ると思います。

もう一回 `ghci` と打ち込んで対話環境を開いてください。

今度は `1 + 1` と入力してEnterを押してみましょう（`ghci>` の部分は入力しません）。すると、計算結果である2が表示されるはずです：

```
ghci> 1 + 1
2
```

掛け算にはアスタリスク `*` を使います。`6 * 5` を打ち込むと6×5が計算されます。

```
ghci> 6 * 5
30
```

演算子の優先順位は通常の数学と同じように、足し算・引き算よりも掛け算・割り算が優先されます。つまり、 `5 - 3 * 4` と打ち込んだら `5 - (3 * 4)` と解釈され、−7が得られます。

```
ghci> 5 - 3 * 4
-7
```

変数を定義することもできます。変数名を左辺に書いて、右辺の式とイコールで結びます。

```
ghci> a = 37
```

`let` を使う書き方もできます。

```
ghci> let a = 37
```

Haskellの変数名は複数文字のものも使えますが、注意事項として、必ず小文字で始める必要があります。大文字で始まる変数を使おうとするとエラーになります：

```
ghci> N = 10

<interactive>:10:1: error: [GHC-76037]
    Not in scope: data constructor ‘N’
```

定義した変数は普通に使うことができます。

```
ghci> a + 5
42
```

ハット記号 `^` でべき乗（自然数乗）を計算することもできます。

```
ghci> (a - 1)^2
1296
```

Haskellは2の100乗のような大きな整数も標準で扱うことができます。

```
ghci> 2^100
1267650600228229401496703205376
```

割り算に関しては、整数除算（結果が整数でない場合は整数へ丸められる）と有理数や実数の割り算（体の演算）とで異なる演算子を使い分けます。

整数除算には `` `div` `` 演算子を使います。バッククォートも演算子名の一部です。

```
ghci> 100 `div` 3
33
```

余りの計算には `` `mod` `` 演算子を使います。

```
ghci> 100 `mod` 3
1
```

負の整数が絡むときの余りは、符号が法と合うものが選択されます。

```
ghci> (-2) `mod` 3
1
```

有理数や実数の割り算にはスラッシュ `/` を使います。

```
ghci> 100 / 3
33.333333333333336
```

「実数」と書きましたが、コンピューター上では正確な実数を取り扱うことはできません。大抵は「表現力」「正確さ」「比較可能性」のどれかが犠牲になります。具体的にそれぞれの特徴を挙げると、

* 表現力を犠牲にする→有理数など、実数の部分集合に取り扱いを限定する。平方根や三角関数などが適用できなくなる。
* 正確さを犠牲にする→有限桁の小数で実数を近似する。さらに細かく、固定小数点数や浮動小数点数などのやり方がある。
* 比較可能性を犠牲にする→計算可能実数を使う。イコールが有限時間で判定できるとは限らない。

となります。

Haskellでデフォルトで使われるのは**浮動小数点数**で、十進で15桁程度の精度があります。ただ、内部的には有限桁の二進小数を使っているので、有限桁の十進小数であっても正確に表現できないことがあります。

例えば、 `0.1` を打ち込むとそのまま0.1が返ってくるように見えますが、

```
ghci> 0.1
0.1
```

0.1を3個足したものを計算させたものは0.3にはなりません：

```
ghci> 0.1 + 0.1 + 0.1
0.30000000000000004
```

このカラクリを説明しておきましょう。あなたが打ち込んだ `0.1` という3文字が表す実数はHaskellが使う浮動小数点数形式では正確に表現できないため、〈0.1に最も近い浮動小数点数〉として解釈されます。値としては0.1よりもほんの少し大きくなります。この値は二進の有限小数なので原理的には十進法でも有限桁で表現できますが、いちいち全ての桁を表示していたら鬱陶しいので、「隣り合う浮動小数点数と区別できる程度の情報を持った十進表記の中で最も短いもの」という風な基準で表示方法が選ばれます。そこで、〈0.1に最も近い浮動小数点数〉の表示は `0.1` となります。

一方で、〈0.1に最も近い浮動小数点数を3倍した数（に最も近い浮動小数点数）〉は〈0.3に最も近い浮動小数点数〉よりもほんの少し大きな数になります。そのため、`0.1 + 0.1 + 0.1` の出力は `0.3` とは異なる小数になるのです。

演習問題：`0.1` を10個足したものは `1.0` になるでしょうか。`0.1` を10倍したものはどうでしょうか。

Haskellでは浮動小数点数のほか、標準で有理数も扱うことができます。有理数を使うには**型**を指定します。

有理数を表す型の名前は `Rational` です。式の型を指定するには式の後にコロン二つ `::` を置いて、型の名前を書きます。例えば、`100 / 3` を有理数として計算する例は次のようになります：

```
ghci> 100 / 3 :: Rational
100 % 3
```

有理数は内部的には既約分数として表現され、分子と分母をパーセント記号 `%` で区切ったものとして表示されます。別の例を計算してみると既約分数であることがわかりやすいでしょう：

```
ghci> 6 / 4 :: Rational
3 % 2
```

これまで扱ってきた整数や浮動小数点数も、それぞれを表す型があります。整数型は `Integer` で、デフォルトの浮動小数点数型は `Double` です。

```
ghci> 100 `div` 3 :: Integer
33
ghci> 100 / 3 :: Double
33.333333333333336
```

整数型が `Integer` なのはいいとして、浮動小数点数型が `Double` なのは不思議ですよね。実はデフォルトの浮動小数点数型は歴史的には倍精度浮動小数点数 (double-precision floating-point number) と呼ばれており、「倍」の部分を取って `Double` と呼ばれているのです。

Haskellには単精度浮動小数点数を表す型 `Float` もあります。これは `Double` よりも表現できる桁数が少ないです：

```
ghci> 100 / 3 :: Float
33.333332
```

Haskellは型に厳格です。例えば、整数型のついた式に対してスラッシュ `/` による除算を行おうとすると**型エラー**が起こります。

```
ghci> (100 :: Integer) / 3

<interactive>:42:18: error: [GHC-39999]
    • No instance for ‘Fractional Integer’ arising from a use of ‘/’
    • In the expression: (100 :: Integer) / 3
      In an equation for ‘it’: it = (100 :: Integer) / 3
```

エラーと聞くと怖いかもしれませんが、型エラーは深刻な事態が起こる前にプログラムの間違いを指摘してくれるやつなので、仲良くしましょう。

Haskellの整数型としては、 `Integer` の他にもいくつかあります。`Int` 型が代表的ですが、`Integer` 以外の整数型は表現できる整数の範囲が限られています。範囲外の値を計算しようとすると、予期しない値が返ってきます。

例えば、`Int` 型で `2^100` と `3^100` を計算してみましょう。

```
ghci> 2^100 :: Int
0
ghci> 3^100 :: Int
-2984622845537545263
```

`2^100` は明らかに0ではないにも関わらず0が返ってきて、`3^100` は明らかに正なのに負の値が返ってきました。

`Int` 型が表現できる範囲は、厳密には環境に依存しますが、今日の環境では$-2^{63}$以上$2^{63}-1$以下のことが多いです。その場合、足し算や掛け算、べき乗はmod $2^{64}$で行われます。

任意の桁数の整数を表現できる `Integer` 型があるのになぜ `Int` などという下位互換が用意されているのかというと、コンピューター上で計算する場合は `Int` の方が高速だからです。Haskellは抽象的な記述ができるプログラミング言語ですが、計算速度を考慮したプログラムも書けるようになっているのです。

対話環境では、`:type` コマンドにより式の型を簡単に調べることができます。`:type` コマンドの後にはスペース区切りで調べたい式を続けます。

```
ghci> :type 2^100
2^100 :: Num a => a
```

おっと、`Integer` などの具体的な型ではなく、 `Num a` や `=>` などの、まだ説明していない型が登場しました。薄々気付いた方もいるかもしれませんが、 `2^100` は `Integer` や `Int` や `Double` を含むいろんな型になれる式で、`Num a => a` は「`Num` 制約を満たす型ならどんな型にでもなれる」ことを表しています。

気を取り直して、具体的な型を型注釈で指定してやると、`:type` コマンドはその型を表示します。

```
ghci> :type (2^100 :: Integer)
(2^100 :: Integer) :: Integer
ghci> a = 37 :: Integer
ghci> :type a
a :: Integer
```

# リスト

コンピューターでプログラムを書く上では、同じ型の値を並べたものを扱うことがよくあります。数学でも数列を扱いますよね。こういうのを**配列** (array)とか**リスト**と呼びます。

プログラミング言語によっては配列とリストを区別しない用法もありますが、Haskellでは「配列」と「リスト」は別の概念です。ここでは「リスト」を扱います。

リストは、コンマ区切りの式を角カッコで囲うことで作ることができます。

```
ghci> [1,3,7]
[1,3,7]
```

Haskellのリストは、空リスト `[]` に幾つかの要素を先頭に連結した形をしています。要素とリストの連結に使う演算子はコロン `:` で、 `[1,3,7]` というリストは `1 : (3 : (7 : []))` と書くこともできます。コロン `:` 演算子は右結合なので、この場合は括弧を省略することもできます。

```
ghci> 1 : (3 : (7 : []))
[1,3,7]
ghci> 1 : 3 : 7 : []
[1,3,7]
```

リストの型は、要素の型を `a` とした時に `[a]` と書きます。

```
ghci> [1,3,7] :: [Integer]
[1,3,7]
```

Haskellの特徴として、等差数列を簡単に書くための記法が用意されています。初項と最終項をドット2つ `..` で区切ります。

```
ghci> [1..10]
[1,2,3,4,5,6,7,8,9,10]
```

差が1ではない場合は、初項と第二項をコンマで区切って、その後にドット2つを書きます。

```
ghci> [1,3..10]
[1,3,5,7,9]
```

最終項を省略した場合は、**無限リスト**が生成されます。万が一実行してしまった場合は、キーボードのコントロールと `C` を同時に押して暴走を止めましょう。

もう一つHaskellの特徴として、**リスト内包表記**というのがあります。リスト内包表記は `[ 式 | 要素の取得元や条件 ]` という形をしていて、要素の取得元として `変数名 <- リストを表す式` を書くことができます。条件は `Bool` 型の式です。

例えば、リスト内包表記を使って1以上100以下の偶数を表すリストを書くと、次のようになります：

```
ghci> [x | x <- [1..100], x `mod` 2 == 0]
[2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100]
```

Haskellでは変数の定義にイコールを使いましたが、「値が等しいこと」を `Bool` 型の式として表すためにはイコールを二つ重ねた演算子 `==` を使います。「値が等しくないこと」は `/=` を使います。数学の≠と似ていますね。

<!-- 関数を使ってリストを生成することもできます。`replicate` 関数を使うと、同じ値からなるリストを生成することができます。`replicate` の後にスペース区切りで個数を、その後にスペース区切りで値を記述します。 --><!-- ghci> replicate 10 0.1 --><!-- [0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1] -->

Haskellにはリストを扱う関数が豊富に用意されています。

`sum` 関数を使うと、総和を計算することができます。

```
ghci> sum [0.1, 0.1, 0.1]
0.30000000000000004
```

`product` 関数を使うと、リストの要素の積を計算することができます。

```
ghci> product [1,2,3,4,5]
120
```

演習問題：`product` 関数を使って、106の階乗を計算してみてください。106の階乗を107で割った余りはいくつでしょうか。

`and` 関数を使うと、リストの要素が全て真であるかどうかを判定できます。Haskellにおいては「真」を表す値は `True` で、「偽」を表す値は `False` です（大文字から始まることに注意）。

```
ghc> and [True, False, True]
False
```

演習問題：空リスト `[]` に対する `and` は何を返すでしょうか。

`length` 関数を使うと、リストの長さを計算することができます。

```
ghci> length [1..10]
10
ghci> length [7..13]
7
```

ここまでの知識で、試し割りによる素数判定を書くことができます。自然数 `p` に対して「2以上 `p-1` 以下の整数 `i` で割り切れないか」を表すリストを作り、リストの要素が全て真であれば素数である、という風にアルゴリズムを組み立てます。具体的な `p` について試してみると、次のようになります：

```
ghci> p = 77
ghci> and [p `mod` i /= 0 | i <- [2..p-1]]
False
ghci> p = 79
ghci> and [p `mod` i /= 0 | i <- [2..p-1]]
True
```

これを使うと、「100以下の素数のリスト」は次のように作れます：

```
ghci> [p | p <- [2..100], and [p `mod` i /= 0 | i <- [2..p-1]]]
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
```

リスト内包表記の条件の部分は `Bool` 型の式であればなんでも（`==` や `/=` でなくても）良いので、`and` 関数の呼び出しをそのまま書けることに注意してください。

演習問題：1000以下の素数は何個あるでしょうか。

<!-- `take` 関数はリストの最初のn項をリストとして返します。 ghci> take 5 [1..100] [1,2,3,4,5] -->

# 関数

Haskellで本格的なプログラムを書くためには**関数**を作る必要があります。

既に `sum` や `product`, `and` などの関数を使いました。さらに、Haskellでは `+` や `*` などの演算子も関数です。

Haskellの関数は直接呼び出すだけではなく、変数に値として代入したり、他の関数に値として渡したり、関数から値として返却することができます。

Haskellで関数を式として書くには、バックスラッシュ[^backslash] `\` の後に引数名を書き、その後に矢印 `->` で区切って関数の本体を書きます。例えば、与えられた数に1加える関数は次のように定義できます：

[^backslash]: `\` が円記号として表示される場合はパソコンを窓から投げ捨ててください（冗談です）。

```
ghci> f = \x -> x + 1
```

これを呼び出すには、関数名と引数をスペース区切りで並べます：

```
ghci> f 0
1
ghci> f 10
11
ghci> f 100
101
```

スペース区切りによる関数適用は、演算子よりも強く結合します。つまり `f 3 * f 4` は `(f 3) * (f 4)` と解釈されます。解釈を変えるには、括弧を使います。

```
ghci> f 3 * f 4
20
ghci> f (3 * f 4)
16
```

関数定義はよく使うので、もっと簡便な書き方も用意されています。イコール `=` の左辺に関数名と引数名を並べ、右辺に本体を書くやり方です：

```
ghci> f x = x + 1
```

演習問題：与えられた整数 `n` の階乗を計算する関数 `factorial` を定義してみてください。`n` は0以上と仮定して構いません。

演習問題：与えられた整数 `n` が素数かどうかを判定する（`Bool` 型の値を返す）関数 `isPrime` を定義してみてください。数の比較は `<`, `<=`, `>`, `>=` などの演算子で行えます。また、2つの条件の「かつ」は `条件1 && 条件2` で、「または」は `条件1 || 条件2` で書けます。

Haskellでは複数の引数を受け取る関数も定義することができます。複数の引数を受け取るには、引数名を複数書きます。複数の引数で呼び出すには、スペース区切りで引数を並べます。

```
ghci> g = \x y -> x + y * 2
ghci> g 2 3
8
```

簡便な関数定義でも複数の引数を取れます：

```
ghci> g x y = x + y * 2
ghci> g 3 4
11
```

関数の型は `引数の型 -> 返り値の型` という形で記述します。例えば、 `Integer` を受け取って `Double` を返す関数の型は `Integer -> Double` です。

先ほどの「1加える」関数 `f` に型注釈をつけるなら次のようになるでしょう：

```
ghci> f = (\x -> x + 1) :: Integer -> Integer
```

他の多くのプログラミング言語と違って、Haskellには「複数の引数を受け取る関数の型」はありません。先ほど定義した「複数の引数を受け取る関数」は実は「関数を返す関数」なのです。

先ほどの `\x y -> x + y * 2` に型をつけるなら次のようになるでしょう：

```
ghci> g = (\x y -> x + y * 2) :: Integer -> Integer -> Integer
```

「簡便な書き方」でも型をつけることができます。その場合、通常は複数行使って最初の行に型注釈を書きます：

```haskell
f :: Integer -> Integer
f x = x + 1
```

ただ、対話環境では一行ずつ解釈されてしまうので、複数行使う書き方を使うには工夫が必要です。一つは、行を分ける代わりにセミコロンを使う書き方です：

```
ghci> f :: Integer -> Integer; f x = x + 1
```

もう一つは、 `:{` コマンドおよび `:}` コマンドを使って複数行をまとめて解釈させる方法です：

```
ghci> :{
ghci| f :: Integer -> Integer
ghci| f x = x + 1
ghci| :}
```

引数の個数が複数個でも同様です：

```
ghci> :{
ghci| g :: Integer -> Integer -> Integer
ghci| g x y = x + y * 2
ghci| :}
```

関数を受け取る関数も使ってみましょう。

リストを処理する関数として `map` があります。この関数は、与えられた関数をリストのすべての要素に適用し、適用結果からなるリストを返します。型は `(a -> b) -> [a] -> [b]` で、最初の引数が関数、二番目の引数がリストです。あるいは、「関数をリスト上の関数に変換する関数」と読むこともできるでしょう。

```
ghci> :type map
map :: (a -> b) -> [a] -> [b]
```

型に登場する小文字（から始まる名前）は型変数で、この場合は（型制約を表す `=>` が含まれないので）任意の型を当てはめることができます。

実際に試してみましょう。先ほど定義した「1加える関数」 `f` をリストの要素に適用してみます：

```
ghci> map f [1,2,4,8]
[2,3,5,9]
```

関数をあらかじめ定義せず、バックスラッシュ記法でその場に書くこともできます。

```
ghci> map (\x -> x + 3) [1,2,4,8]
[4,5,7,11]
```

先ほどの `g :: Integer -> Integer -> Integer` を適用してみるとどうなるでしょうか。

```
ghci> map g [1,2,4,8]

<interactive>:13:1: error:
    • No instance for (Show (Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
```

何やらエラーが出ました。`g` は「整数を受け取って関数を返す関数」なので適用自体は可能で、「関数からなるリスト」が返ってくるのですが、「関数からなるリスト」を対話環境上で文字列として表示する方法がないため、エラーとなっているのです。

型を確認してみると、確かに「関数からなるリスト」となっていることがわかります。

```
ghci> :type map g [1,2,4,8]
map g [1,2,4,8] :: [Integer -> Integer]
```

また、一旦変数に代入して改めて `map` を使うこともできます。

```
ghci> list = map g [1,2,4,8]
ghci> map (\f -> f 5) list
[11,12,14,18]
```

先ほど「リストのすべての要素が真（`True`）か」を判定する関数 `and` を紹介しましたが、もう少し一般化した「リストのすべての要素が条件を満たすか」を判定する関数 `all` もHaskellには用意されています。こちらの方が使用頻度が高いかもしれません。

`all` の型は `(a -> Bool) -> [a] -> Bool` という形をしています（実際にはもう少し一般化された型をしており、 `:type` コマンドはそれを表示します）。

例えば、「リストのすべての要素が3以上か」を判定する処理は次のように書けます：

```
ghci> all (\x -> x >= 3) [3,5,7]
True
ghci> all (\x -> x >= 3) [1,3,5,7]
False
```

# ファイルから読み込む

プログラムが複雑になってくると、対話環境にいちいち打ち込むのは大変になります。というわけで、プログラムをファイルに書いてみましょう。

好みのテキストエディターで、次の内容のテキストファイルを作ります：

```haskell
factorial :: Integer -> Integer
factorial n = product [1..n]
```

ここでは `fact.hs` という名前で保存します。

<!-- 保存先が面倒くさい -->

`fact.hs` を保存したフォルダーで対話環境を開きます。ファイルを読み込むには `:load` コマンドを使います。

```
ghci> :load "fact.hs"
[1 of 2] Compiling Main             ( fact.hs, interpreted )
Ok, one module loaded.
```

ファイル中で定義した `factorial` 関数を使ってみましょう。

```
ghci> :type factorial
factorial :: Integer -> Integer
ghci> factorial 5
120
```

上手く使えているようです。

---

# 演習問題の解答

演習問題：`0.1` を10個足したものは `1.0` になるでしょうか。`0.1` を10倍したものはどうでしょうか。

```
ghci> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1
0.9999999999999999
ghci> 0.1 * 10
1.0
```

ちなみに、型が `Float` の場合は

```
ghci> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 :: Float
1.0000001
ghci> 0.1 * 10 :: Float
1.0
```

となります。
