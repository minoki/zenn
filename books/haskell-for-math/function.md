---
title: "関数"
---

「対話環境で遊ぶ」では主に既製品の関数を使って計算を行いましたが、実際のプログラミングではもっと複雑な関数が必要になる場合が多いでしょう。そういうわけで、この節では、より複雑な関数を定義する方法を見てみます。

# 再帰的な定義

これまでは、変数や関数の定義の右辺には定義しようとしている変数・関数は登場しませんでした。これに対して、定義の右辺に定義しようとしている変数関数が登場するものを、**再帰**的な定義とか、**再帰関数**と呼びます。

とは言っても、右辺での登場の仕方は何でもいいわけではありません。数学では$x = x^2 - 1$と書いたら$x$は方程式の解を表すかもしれませんが、Haskellで `x = x^2 - 1` と `x` を定義すると「停止しない」プログラムが出来上がってしまいます。

試しに対話環境で `x = x^2 - 1` を定義してみましょう。

```
ghci> x = x^2 - 1
```

Haskellでは変数を定義した時点では計算は行われず、値を利用しようとした時に計算が行われます。ここでは「`x` の値を表示する」という形で「利用」してみましょう。

```
ghci> x
```

いつもとは違い、結果も `ghci>` も表示されないと思います。これはこのプログラムが「停止しない」状態、いわゆる無限ループに陥ってしまったためです。対話環境ではCtrlキーとCを同時に押すことでプログラムを無理やり中断することができます。

意味のある再帰的な定義は、数学での漸化式による数列の定義と似ています。つまり、何らかの初項を決めておき、定義を有限回展開することによって初項に到達するようなものです。

例えば、階乗を漸化式で定義すると

$$
\begin{aligned}
0!&=1, \\
n!&=n\cdot (n-1)!
\end{aligned}
$$

ですが、これをHaskellで定義すると

```haskell
factorial n = if n == 0 then 1 else n * factorial (n - 1)
```

となります。ここで登場した**if式**は `if 式 then 式 else 式` という形をしており、`if` と `then` で挟まれた条件が真（`True`）なら `then` の後の式に評価され、偽（`False`）なら `else` の後の式に評価されます。

この再帰的な `factorial` の定義では、「初項」に相当する条件（`n` が0なら1を返す）があり、そうでない場合は `factorial (n - 1)` という風に引数を小さくして自分自身を呼び出しています。このため、引数が0以上の整数なら問題なく停止する関数が実装できています。

ちなみに、上記の `factorial` の定義では引数が負の場合はやっぱり無限ループに陥ります。数学では「定義がうまくいくこと」に細心の注意を払いますが、プログラミングでは「停止しない関数」あるいは「エラーを出す関数」を簡単に書けてしまう、という違いがあります（両者の中間に位置する言語もありますが、Haskellはそうではない）。

さて、こういう「場合分けによる定義」はよく使われるので、Haskellではもっと簡便な書き方が用意されています。一つは「ガード節」と呼ばれる構文で、縦棒 `|` を使って条件とそれぞれの定義本体を記述できます：

```haskell
factorial n | n == 0 = 1
            | otherwise = n * factorial (n - 1)
```

ガード節は上から順番に検査されます。`otherwise` は「真」を表す変数なので、（それまでに書かれたガード節の条件を満たさなければ）常にガード節の右辺が使用されます。

もう一つはパターンマッチによる定義で、値が特定の「形」をしているかを判別します。

```haskell
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

パターンマッチの場合も上から順番に検査されます。`factorial n = n * factorial (n - 1)` の行が使用されるのは前の行にマッチしなかった場合のみです。

この例だとガード節とパターンマッチのいずれでも書けますが、もっと複雑なプログラムになると見た目以上の違いが出てきます。

ガード節にせよ、パターンマッチにせよ、定義には複数行を要します。対話環境で定義する場合は適宜 `:{` コマンドと `:}` コマンドを使うと良いでしょう。

演習問題：自然数$n$の**二重階乗**$n!!$は以下の漸化式で定義されます。

$$
\begin{aligned}
0!!&=1, \\
1!!&=1, \\
n!!&=n\cdot (n-2)!!
\end{aligned}
$$

これを計算するHaskellの関数 `doubleFactorial` を定義してください。

<!--プログラミングでは繰り返し処理を行いたいことがよくあります。数学でもそれは同じで、例えば総和は「足し算を繰り返す」ことですし、べき乗、階乗、総乗は「掛け算を繰り返す」ことです。数列を漸化式で定義する時は、「定義式を繰り返し適用する」ことによって数列の値を計算できます。-->

## ユークリッドの互除法

次に、より非自明なアルゴリズムとして、**ユークリッドの互除法**を取り上げます。

自然数$a$と$b$の**最大公約数**は、$a$と$b$をともに割り切るような自然数のうち、整除関係で最大となるもの、と定義します。$a$と0の最大公約数は$a$で、特に$0$と$0$の最大公約数は0です。

$a$と$b$の最大公約数を$\gcd(a,b)$と表記します。以下が成り立ちます：

$$
\begin{aligned}
\gcd(a,b)&=\gcd(b,a),\\
\gcd(0,b)&=b,\\
\gcd(a,b)&=\gcd(a-b,b)
\end{aligned}
$$

3番目の式を繰り返し適用すると自然数$n$について$\gcd(a,b)=\gcd(a-nb,b)$を得て、特に$a$を$b$で割った余りを$r$とした時に$\gcd(a,b)=\gcd(r,b)$が成り立ちます。さらに1番目の式より

$$
\gcd(a,b)=\gcd(b,r)
$$

を得ます。

この等式を繰り返し適用すれば、$a$と$b$の最大公約数を求めることができます。例えば、74と14の最大公約数を計算してみましょう。

$$
\begin{aligned}
\gcd(74,14)&=\gcd(14,4) & \text{(74を14で割った余りは4)} \\
&=\gcd(4,2) & \text{(14を4で割った余りは2)} \\
&=\gcd(2,0) & \text{(4を2で割った余りは0)} \\
&=2 & \text{(0との最大公約数)}
\end{aligned}
$$

という風に、最大公約数が2と求まります。

このアルゴリズムを分析するために、もう少し形式的に話をしましょう。
数列$\{a_n\}$の最初の2項を$a_0=a$, $a_1=b$とし、それ以降の$a_n$ ($n=1,2,3,\ldots$) を順次次のように定めます：

1. $a_{n+1}$が0なら停止する。最大公約数は$a_n$である。
2. そうでなければ$a_{n+2}=\langle\text{\(a_n\)を\(a_{n+1}\)で割った余り}\rangle$と定める。

このアルゴリズムが停止することは、次のように分かります。$n\ge 2$について、割り算の余りの性質より$0\le a_n<a_{n-1}$が成り立ちます。つまり$\{a_n\}$は自然数の降下列$\cdots<a_n<a_{n-1}<\cdots<a_2<a_1$をなします。よって数列$\{a_n\}$は有限ステップで0に到達します。

$a_{N+1}=0$となるとき、$a$と$b$の最大公約数は

$$
\begin{aligned}
\gcd(a,b)&=\gcd(a_0,a_1) \\
&=\gcd(a_1,a_2) \\
&=\gcd(a_2,a_3) \\
&\vdots \\
&=\gcd(a_N,0) \\
&=a_N
\end{aligned}
$$

と求まります。

このアルゴリズムに基づいて$\gcd$の漸化式を書くと、

$$
\gcd(a,b)=\begin{cases}
a & (b=0) \\
\gcd(b,a\bmod b) & (b\ne 0)
\end{cases}
$$

となります。数列$\{a_n\}$はアルゴリズムの分析には有用ですが、実装の際に登場させる必要はないことに注意してください。

Haskellでの実装は次のようになります。関数の名前は `gcd` としたいところですが、`gcd` という名前はすでに標準ライブラリーで定義済みなので、ここでは代わりに `euclid` とします。「aをbで割った余り」は ``a `mod` b`` で計算できるのでした。

```haskell
euclid :: Integer -> Integer -> Integer
euclid a b | b == 0 = a
           | otherwise = euclid b (a `mod` b)
```

対話環境に（ファイルあるいは `:{` `:}` コマンドで）この定義を読み込んで、計算してみましょう。

```
ghci> euclid 100 150
50
ghci> euclid 33 57
3
ghci> euclid 5 8
1
```

うまく計算できましたか？
